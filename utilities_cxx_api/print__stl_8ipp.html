<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: include/utilities/printing/print_stl.ipp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">utilities
   &#160;<span id="projectnumber">0.1.27</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_52b4106b6168f13dcdf82e33b1d195ee.html">utilities</a></li><li class="navelem"><a class="el" href="dir_801724335bc5d75d2401e890fe298ff2.html">printing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">print_stl.ipp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="print__stl_8hpp_source.html">utilities/printing/print_stl.hpp</a>&quot;</code><br />
<code>#include &quot;utilities/type_traits/is_printable.hpp&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for print_stl.ipp:</div>
<div class="dyncontent">
<div class="center"><img src="print__stl_8ipp__incl.png" border="0" usemap="#ainclude_2utilities_2printing_2print__stl_8ipp" alt=""/></div>
<map name="ainclude_2utilities_2printing_2print__stl_8ipp" id="ainclude_2utilities_2printing_2print__stl_8ipp">
<area shape="rect" title=" " alt="" coords="595,5,771,47"/>
<area shape="rect" href="print__stl_8hpp.html" title=" " alt="" coords="620,184,745,225"/>
<area shape="rect" href="is__printable_8hpp_source.html" title=" " alt="" coords="733,95,878,136"/>
<area shape="rect" title=" " alt="" coords="5,273,61,300"/>
<area shape="rect" title=" " alt="" coords="86,273,149,300"/>
<area shape="rect" title=" " alt="" coords="173,273,272,300"/>
<area shape="rect" title=" " alt="" coords="296,273,339,300"/>
<area shape="rect" title=" " alt="" coords="363,273,413,300"/>
<area shape="rect" title=" " alt="" coords="437,273,512,300"/>
<area shape="rect" title=" " alt="" coords="1310,273,1386,300"/>
<area shape="rect" title=" " alt="" coords="537,273,599,300"/>
<area shape="rect" title=" " alt="" coords="624,273,667,300"/>
<area shape="rect" title=" " alt="" coords="691,273,749,300"/>
<area shape="rect" title=" " alt="" coords="773,273,827,300"/>
<area shape="rect" title=" " alt="" coords="851,273,975,300"/>
<area shape="rect" title=" " alt="" coords="1000,273,1115,300"/>
<area shape="rect" title=" " alt="" coords="1139,273,1199,300"/>
<area shape="rect" title=" " alt="" coords="1223,273,1286,300"/>
<area shape="rect" title=" " alt="" coords="843,191,935,218"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="print__stl_8ipp__dep__incl.png" border="0" usemap="#ainclude_2utilities_2printing_2print__stl_8ippdep" alt=""/></div>
<map name="ainclude_2utilities_2printing_2print__stl_8ippdep" id="ainclude_2utilities_2printing_2print__stl_8ippdep">
<area shape="rect" title=" " alt="" coords="5,5,181,47"/>
<area shape="rect" href="print__stl_8hpp.html" title=" " alt="" coords="5,95,181,136"/>
<area shape="rect" href="is__printable_8hpp_source.html" title=" " alt="" coords="71,184,241,225"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html">utilities</a></td></tr>
<tr class="memdesc:namespaceutilities"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for all functionality in the Utilities library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad54291c8b263c13d9d4ca45115e30cdf"><td class="memTemplParams" colspan="2"><a id="ad54291c8b263c13d9d4ca45115e30cdf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad54291c8b263c13d9d4ca45115e30cdf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::printing::detail_::print_element</b> (std::ostream &amp;os, T &amp;&amp;value)</td></tr>
<tr class="separator:ad54291c8b263c13d9d4ca45115e30cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d30340e6d6dbf2b77e7f42a8cae61bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fxn &gt; </td></tr>
<tr class="memitem:a5d30340e6d6dbf2b77e7f42a8cae61bc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a5d30340e6d6dbf2b77e7f42a8cae61bc">utilities::printing::detail_::print_queue</a> (std::ostream &amp;os, Fxn &amp;&amp;f, T &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a5d30340e6d6dbf2b77e7f42a8cae61bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements printing of queue-like containers.  <a href="print__stl_8hpp.html#a5d30340e6d6dbf2b77e7f42a8cae61bc">More...</a><br /></td></tr>
<tr class="separator:a5d30340e6d6dbf2b77e7f42a8cae61bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7f759323fccd1a94c00e641159bdd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00f7f759323fccd1a94c00e641159bdd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a00f7f759323fccd1a94c00e641159bdd">utilities::printing::detail_::print_list</a> (std::ostream &amp;os, T &amp;&amp;rhs, char odelim='[', char cdelim=']')</td></tr>
<tr class="memdesc:a00f7f759323fccd1a94c00e641159bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a list-like container.  <a href="print__stl_8hpp.html#a00f7f759323fccd1a94c00e641159bdd">More...</a><br /></td></tr>
<tr class="separator:a00f7f759323fccd1a94c00e641159bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af461f4125ff44089aa96a42fab497674"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af461f4125ff44089aa96a42fab497674"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#af461f4125ff44089aa96a42fab497674">utilities::printing::detail_::print_associative</a> (std::ostream &amp;os, T &amp;&amp;rhs, char odelim='{', char cdelim='}')</td></tr>
<tr class="memdesc:af461f4125ff44089aa96a42fab497674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an associative container.  <a href="print__stl_8hpp.html#af461f4125ff44089aa96a42fab497674">More...</a><br /></td></tr>
<tr class="separator:af461f4125ff44089aa96a42fab497674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c84f4845c5c7393c07b4cf9344655"><td class="memTemplParams" colspan="2">template&lt;std::size_t depth, typename T &gt; </td></tr>
<tr class="memitem:abd0c84f4845c5c7393c07b4cf9344655"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#abd0c84f4845c5c7393c07b4cf9344655">utilities::printing::detail_::print_tuple</a> (std::ostream &amp;os, T &amp;&amp;rhs, char odelim='(', char cdelim=')')</td></tr>
<tr class="memdesc:abd0c84f4845c5c7393c07b4cf9344655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for printing tuple/pairs.  <a href="print__stl_8hpp.html#abd0c84f4845c5c7393c07b4cf9344655">More...</a><br /></td></tr>
<tr class="separator:abd0c84f4845c5c7393c07b4cf9344655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261746bdac7f8c64974efb4dd7d16fa2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a261746bdac7f8c64974efb4dd7d16fa2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a261746bdac7f8c64974efb4dd7d16fa2">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a261746bdac7f8c64974efb4dd7d16fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::array printable.  <a href="print__stl_8hpp.html#a261746bdac7f8c64974efb4dd7d16fa2">More...</a><br /></td></tr>
<tr class="separator:a261746bdac7f8c64974efb4dd7d16fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7092c8f117f385cbc6158277e2b1b9b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:ac7092c8f117f385cbc6158277e2b1b9b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#ac7092c8f117f385cbc6158277e2b1b9b">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::deque&lt; T, Alloc &gt; &amp;d)</td></tr>
<tr class="memdesc:ac7092c8f117f385cbc6158277e2b1b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::deque printable.  <a href="print__stl_8hpp.html#ac7092c8f117f385cbc6158277e2b1b9b">More...</a><br /></td></tr>
<tr class="separator:ac7092c8f117f385cbc6158277e2b1b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456558c987710422759ee9c08f62292f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a456558c987710422759ee9c08f62292f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a456558c987710422759ee9c08f62292f">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::forward_list&lt; T, Alloc &gt; &amp;f)</td></tr>
<tr class="memdesc:a456558c987710422759ee9c08f62292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::forward_list printable.  <a href="print__stl_8hpp.html#a456558c987710422759ee9c08f62292f">More...</a><br /></td></tr>
<tr class="separator:a456558c987710422759ee9c08f62292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0f2e3ed18e752c1cd50f74cb1d891"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename Compare , typename Alloc &gt; </td></tr>
<tr class="memitem:affb0f2e3ed18e752c1cd50f74cb1d891"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#affb0f2e3ed18e752c1cd50f74cb1d891">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::map&lt; Key, T, Compare, Alloc &gt; &amp;m)</td></tr>
<tr class="memdesc:affb0f2e3ed18e752c1cd50f74cb1d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::list printable.  <a href="print__stl_8hpp.html#affb0f2e3ed18e752c1cd50f74cb1d891">More...</a><br /></td></tr>
<tr class="separator:affb0f2e3ed18e752c1cd50f74cb1d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47554d8b3d142ff400a49af79867bc0a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename Compare , typename Alloc &gt; </td></tr>
<tr class="memitem:a47554d8b3d142ff400a49af79867bc0a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a47554d8b3d142ff400a49af79867bc0a">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::multimap&lt; Key, T, Compare, Alloc &gt; &amp;m)</td></tr>
<tr class="memdesc:a47554d8b3d142ff400a49af79867bc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::multimap printable.  <a href="print__stl_8hpp.html#a47554d8b3d142ff400a49af79867bc0a">More...</a><br /></td></tr>
<tr class="separator:a47554d8b3d142ff400a49af79867bc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a9a4a0d5b1cc90acb9b20b85af0354"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare , typename Alloc &gt; </td></tr>
<tr class="memitem:ae3a9a4a0d5b1cc90acb9b20b85af0354"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#ae3a9a4a0d5b1cc90acb9b20b85af0354">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::multiset&lt; T, Compare, Alloc &gt; &amp;s)</td></tr>
<tr class="memdesc:ae3a9a4a0d5b1cc90acb9b20b85af0354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::multiset printable.  <a href="print__stl_8hpp.html#ae3a9a4a0d5b1cc90acb9b20b85af0354">More...</a><br /></td></tr>
<tr class="separator:ae3a9a4a0d5b1cc90acb9b20b85af0354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88c6eb9547522d49d4edb34a8e885a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac88c6eb9547522d49d4edb34a8e885a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#ac88c6eb9547522d49d4edb34a8e885a6">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::optional&lt; T &gt; &amp;o)</td></tr>
<tr class="memdesc:ac88c6eb9547522d49d4edb34a8e885a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::optional printable.  <a href="print__stl_8hpp.html#ac88c6eb9547522d49d4edb34a8e885a6">More...</a><br /></td></tr>
<tr class="separator:ac88c6eb9547522d49d4edb34a8e885a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f221eb2b034e65343f46e40ca135d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1b4f221eb2b034e65343f46e40ca135d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a1b4f221eb2b034e65343f46e40ca135d">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::pair&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="memdesc:a1b4f221eb2b034e65343f46e40ca135d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::pair printable.  <a href="print__stl_8hpp.html#a1b4f221eb2b034e65343f46e40ca135d">More...</a><br /></td></tr>
<tr class="separator:a1b4f221eb2b034e65343f46e40ca135d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0171139dd938d8971145e2775fa14852"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a0171139dd938d8971145e2775fa14852"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a0171139dd938d8971145e2775fa14852">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, std::priority_queue&lt; T, Container, Compare &gt; q)</td></tr>
<tr class="memdesc:a0171139dd938d8971145e2775fa14852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::priority_queue printable.  <a href="print__stl_8hpp.html#a0171139dd938d8971145e2775fa14852">More...</a><br /></td></tr>
<tr class="separator:a0171139dd938d8971145e2775fa14852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac3ee6c10603c9d1ba4e643cc89f692"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:acac3ee6c10603c9d1ba4e643cc89f692"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#acac3ee6c10603c9d1ba4e643cc89f692">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, std::queue&lt; T, Container &gt; q)</td></tr>
<tr class="memdesc:acac3ee6c10603c9d1ba4e643cc89f692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::queue printable.  <a href="print__stl_8hpp.html#acac3ee6c10603c9d1ba4e643cc89f692">More...</a><br /></td></tr>
<tr class="separator:acac3ee6c10603c9d1ba4e643cc89f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d448a9ce77c6f4f051f9a824fce0ca"><td class="memTemplParams" colspan="2"><a id="a78d448a9ce77c6f4f051f9a824fce0ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78d448a9ce77c6f4f051f9a824fce0ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::printing::operator&lt;&lt;</b> (std::ostream &amp;os, const std::reference_wrapper&lt; T &gt; &amp;r)</td></tr>
<tr class="separator:a78d448a9ce77c6f4f051f9a824fce0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584f668667d23b37a6f43ea6d9c9ed19"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare , typename Alloc &gt; </td></tr>
<tr class="memitem:a584f668667d23b37a6f43ea6d9c9ed19"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a584f668667d23b37a6f43ea6d9c9ed19">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::set&lt; T, Compare, Alloc &gt; &amp;s)</td></tr>
<tr class="memdesc:a584f668667d23b37a6f43ea6d9c9ed19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::set printable.  <a href="print__stl_8hpp.html#a584f668667d23b37a6f43ea6d9c9ed19">More...</a><br /></td></tr>
<tr class="separator:a584f668667d23b37a6f43ea6d9c9ed19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70fb8af9751fba4c2c4040fb9f3d1bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:aa70fb8af9751fba4c2c4040fb9f3d1bd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#aa70fb8af9751fba4c2c4040fb9f3d1bd">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, std::stack&lt; T, Container &gt; s)</td></tr>
<tr class="memdesc:aa70fb8af9751fba4c2c4040fb9f3d1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::stack printable.  <a href="print__stl_8hpp.html#aa70fb8af9751fba4c2c4040fb9f3d1bd">More...</a><br /></td></tr>
<tr class="separator:aa70fb8af9751fba4c2c4040fb9f3d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6c04f9300516d8521396fd96f9321f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a1f6c04f9300516d8521396fd96f9321f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a1f6c04f9300516d8521396fd96f9321f">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::tuple&lt; Types... &gt; &amp;t)</td></tr>
<tr class="memdesc:a1f6c04f9300516d8521396fd96f9321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::tuple printable.  <a href="print__stl_8hpp.html#a1f6c04f9300516d8521396fd96f9321f">More...</a><br /></td></tr>
<tr class="separator:a1f6c04f9300516d8521396fd96f9321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0030c5af78bb628ab4f889acae82c626"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename Hash , typename Pred , typename Alloc &gt; </td></tr>
<tr class="memitem:a0030c5af78bb628ab4f889acae82c626"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a0030c5af78bb628ab4f889acae82c626">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::unordered_map&lt; Key, T, Hash, Pred, Alloc &gt; &amp;m)</td></tr>
<tr class="memdesc:a0030c5af78bb628ab4f889acae82c626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::unordered_map printable.  <a href="print__stl_8hpp.html#a0030c5af78bb628ab4f889acae82c626">More...</a><br /></td></tr>
<tr class="separator:a0030c5af78bb628ab4f889acae82c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537cfeb9c72dd8749d0fc6d153649af5"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename Hash , typename Pred , typename Alloc &gt; </td></tr>
<tr class="memitem:a537cfeb9c72dd8749d0fc6d153649af5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a537cfeb9c72dd8749d0fc6d153649af5">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::unordered_multimap&lt; Key, T, Hash, Pred, Alloc &gt; &amp;m)</td></tr>
<tr class="memdesc:a537cfeb9c72dd8749d0fc6d153649af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::unordered_multimap printable.  <a href="print__stl_8hpp.html#a537cfeb9c72dd8749d0fc6d153649af5">More...</a><br /></td></tr>
<tr class="separator:a537cfeb9c72dd8749d0fc6d153649af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c067f824cc90ebb74cef69b54ff2ae"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Hash , typename Pred , typename Alloc &gt; </td></tr>
<tr class="memitem:aa7c067f824cc90ebb74cef69b54ff2ae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#aa7c067f824cc90ebb74cef69b54ff2ae">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::unordered_multiset&lt; Key, Hash, Pred, Alloc &gt; &amp;s)</td></tr>
<tr class="memdesc:aa7c067f824cc90ebb74cef69b54ff2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::unordered_multiset printable.  <a href="print__stl_8hpp.html#aa7c067f824cc90ebb74cef69b54ff2ae">More...</a><br /></td></tr>
<tr class="separator:aa7c067f824cc90ebb74cef69b54ff2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba5c9333ab7b918c0da6f81a55fe6c5"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Hash , typename Pred , typename Alloc &gt; </td></tr>
<tr class="memitem:a0ba5c9333ab7b918c0da6f81a55fe6c5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#a0ba5c9333ab7b918c0da6f81a55fe6c5">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::unordered_set&lt; Key, Hash, Pred, Alloc &gt; &amp;s)</td></tr>
<tr class="memdesc:a0ba5c9333ab7b918c0da6f81a55fe6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::unordered_set printable.  <a href="print__stl_8hpp.html#a0ba5c9333ab7b918c0da6f81a55fe6c5">More...</a><br /></td></tr>
<tr class="separator:a0ba5c9333ab7b918c0da6f81a55fe6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c951dd7a51e5256c5046b54826865"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:ade7c951dd7a51e5256c5046b54826865"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="print__stl_8hpp.html#ade7c951dd7a51e5256c5046b54826865">utilities::printing::operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T, Alloc &gt; &amp;v)</td></tr>
<tr class="memdesc:ade7c951dd7a51e5256c5046b54826865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes std::vector printable.  <a href="print__stl_8hpp.html#ade7c951dd7a51e5256c5046b54826865">More...</a><br /></td></tr>
<tr class="separator:ade7c951dd7a51e5256c5046b54826865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The new operator&lt;&lt; functions need to be declared before type_traits::is_printable is checked. The implementation of those functions is then handled here. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a261746bdac7f8c64974efb4dd7d16fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261746bdac7f8c64974efb4dd7d16fa2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::array printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the element stored in the array. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements stored in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print the array to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The array to print. Elements of the array must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>a</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7092c8f117f385cbc6158277e2b1b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7092c8f117f385cbc6158277e2b1b9b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::deque&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::deque printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the element stored in the deque. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the deque's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The deque to print. Elements of the deque must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>a</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a456558c987710422759ee9c08f62292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456558c987710422759ee9c08f62292f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::forward_list&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::forward_list printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the element stored in the forward_list. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the forward_list's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The forward_list to print. Elements of the forward_list must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>f</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affb0f2e3ed18e752c1cd50f74cb1d891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb0f2e3ed18e752c1cd50f74cb1d891">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Compare , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::list printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the element stored in the list. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the list's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>The list to print. Elements of the list must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>l</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Makes std::map printable.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the keys in the map </td></tr>
    <tr><td class="paramname">T</td><td>The type of the value stored in the map. </td></tr>
    <tr><td class="paramname">Compare</td><td>The type of the functor used for comparing keys. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the map's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The map to print. Keys and values of the map must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>m</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47554d8b3d142ff400a49af79867bc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47554d8b3d142ff400a49af79867bc0a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Compare , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; Key, T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::multimap printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the keys in the multimap </td></tr>
    <tr><td class="paramname">T</td><td>The type of the value stored in the multimap. </td></tr>
    <tr><td class="paramname">Compare</td><td>The type of the functor used for comparing keys. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the multimap's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The multimap to print. Keys and values of the multimap must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>m</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a9a4a0d5b1cc90acb9b20b85af0354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9a4a0d5b1cc90acb9b20b85af0354">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multiset&lt; T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::multiset printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values stored in the multiset </td></tr>
    <tr><td class="paramname">Compare</td><td>The functor to use for ordering elements. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The allocator for the set</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The multiset to print. Values in the multiset must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac88c6eb9547522d49d4edb34a8e885a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88c6eb9547522d49d4edb34a8e885a6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::optional printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value inside the optional</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The stream to print the optional to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>The optional to print. If it holds a value, the value must be printable; if it does not hold a value "nullopt" will be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> containing <code>o</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if std::ostream::operator&lt;&lt; throws. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b4f221eb2b034e65343f46e40ca135d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4f221eb2b034e65343f46e40ca135d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::pair printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first value stored in the pair </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the second value stored in the pair</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The pair to print. Values in the pair must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>p</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a584f668667d23b37a6f43ea6d9c9ed19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584f668667d23b37a6f43ea6d9c9ed19">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::set printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values stored in the set </td></tr>
    <tr><td class="paramname">Compare</td><td>The functor to use for ordering elements. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The allocator for the set</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The set to print. Values in the set must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f6c04f9300516d8521396fd96f9321f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6c04f9300516d8521396fd96f9321f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::tuple printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>The types in the tuple</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tuple to print. Values in the tuple must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>t</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0030c5af78bb628ab4f889acae82c626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0030c5af78bb628ab4f889acae82c626">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename Pred , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; Key, T, Hash, Pred, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::unordered_map printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the keys in the unordered_map </td></tr>
    <tr><td class="paramname">T</td><td>The type of the value stored in the unordered_map. </td></tr>
    <tr><td class="paramname">Hash</td><td>The type of the hash functor </td></tr>
    <tr><td class="paramname">Pred</td><td>The type of the functor used for comparing hashes. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the unordered_map's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The unordered_map to print. Keys and values of the unordered_map must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>m</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a537cfeb9c72dd8749d0fc6d153649af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537cfeb9c72dd8749d0fc6d153649af5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename Pred , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_multimap&lt; Key, T, Hash, Pred, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::unordered_multimap printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the keys in the unordered_multimap </td></tr>
    <tr><td class="paramname">T</td><td>The type of the value stored in the unordered_multimap. </td></tr>
    <tr><td class="paramname">Hash</td><td>The type of the hash functor </td></tr>
    <tr><td class="paramname">Pred</td><td>The type of the functor used for comparing hashes. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the unordered_multimap's allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The unordered_multimap to print. Keys and values of the unordered_multimap must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>m</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7c067f824cc90ebb74cef69b54ff2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c067f824cc90ebb74cef69b54ff2ae">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_multiset&lt; Key, Hash, Pred, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::unordered_multiset printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the elements in the unordered_multiset </td></tr>
    <tr><td class="paramname">Hash</td><td>The type of the hash functor </td></tr>
    <tr><td class="paramname">Pred</td><td>The type of the functor used for comparing hashes. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The unordered_multiset to print. Keys of the unordered_multiset must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ba5c9333ab7b918c0da6f81a55fe6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba5c9333ab7b918c0da6f81a55fe6c5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; Key, Hash, Pred, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::unordered_set printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the elements in the unordered_set </td></tr>
    <tr><td class="paramname">Hash</td><td>The type of the hash functor </td></tr>
    <tr><td class="paramname">Pred</td><td>The type of the functor used for comparing hashes. </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The unordered_set to print. Keys of the unordered_set must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade7c951dd7a51e5256c5046b54826865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7c951dd7a51e5256c5046b54826865">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::vector printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elments in the vector </td></tr>
    <tr><td class="paramname">Alloc</td><td>The type of the allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The vector to print. Elements of the vector must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>v</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0171139dd938d8971145e2775fa14852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0171139dd938d8971145e2775fa14852">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, Container, Compare &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::priority_queue printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values stored in the priority_queue. </td></tr>
    <tr><td class="paramname">Container</td><td>The type of the container the priority_queue is built around. </td></tr>
    <tr><td class="paramname">Compare</td><td>The functor to use for comparing priorities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The priority_queue to print. Values in the priorty_queue must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>q</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acac3ee6c10603c9d1ba4e643cc89f692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac3ee6c10603c9d1ba4e643cc89f692">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, Container &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::queue printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values stored in the queue. </td></tr>
    <tr><td class="paramname">Container</td><td>The type of the container the queue is built around</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue to print. Values in the queue must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>q</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa70fb8af9751fba4c2c4040fb9f3d1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70fb8af9751fba4c2c4040fb9f3d1bd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, Container &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes std::stack printable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values stored in the stack. </td></tr>
    <tr><td class="paramname">Container</td><td>The type of the container the stack is built around</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The stack to print. Values in the stack must be printable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> modified to contain <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the ostream's operator&lt;&lt; throws. Same exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af461f4125ff44089aa96a42fab497674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af461f4125ff44089aa96a42fab497674">&#9670;&nbsp;</a></span>print_associative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::detail_::print_associative </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>odelim</em> = <code>'{'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cdelim</em> = <code>'}'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an associative container. </p>
<p>Associative containers need to print key, value pairs. This should be contrasted with list-like containers, which only need to print the values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container that is being printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print the container to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The container to print to the stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">open_delim</td><td>The character to use to denote the start of the container. Default is <code>{</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">close_delim</td><td>The character to use to denote the end of the container. Default is <code>}</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> containing <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if std::ostream&lt;&lt; throws. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00f7f759323fccd1a94c00e641159bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f7f759323fccd1a94c00e641159bdd">&#9670;&nbsp;</a></span>print_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::detail_::print_list </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>odelim</em> = <code>'['</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cdelim</em> = <code>']'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a list-like container. </p>
<p>List like containers only need to print the elements. This should be contrasted with associative containers, which need to print a key and a value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container that is being printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The std::ostream to print the container to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The container to print to the stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">open_delim</td><td>The character to use to denote the start of the container. Default is <code>[</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">close_delim</td><td>The character to use to denote the end of the container. Default is <code>]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> containing <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if std::ostream&lt;&lt; throws. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d30340e6d6dbf2b77e7f42a8cae61bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d30340e6d6dbf2b77e7f42a8cae61bc">&#9670;&nbsp;</a></span>print_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fxn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::detail_::print_queue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fxn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements printing of queue-like containers. </p>
<p>Queue like containers only allow you to view the elements that are in the front of the queue or on top of the stack. Hence this function iterates over the container by getting the first element from a functor (used to abstract away the fact that different containers have different accessors for this element), popping that element off, and repeating until the container is empty. It's consequentially a good idea to use a copy of the original container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the queue-like container we are printing. </td></tr>
    <tr><td class="paramname">Fxn</td><td>The functor which returns the first element in the queue given the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The stream to print to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The functor to use for retrieving elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The container to print. The contents of which will be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> containing <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if std::ostream&lt;&lt; throws. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0c84f4845c5c7393c07b4cf9344655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0c84f4845c5c7393c07b4cf9344655">&#9670;&nbsp;</a></span>print_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t depth, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; utilities::printing::detail_::print_tuple </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>odelim</em> = <code>'('</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cdelim</em> = <code>')'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for printing tuple/pairs. </p>
<p>Tuples don't support iteration, consequentially this function works by recursion. At a recursive depth of <code>depth</code> this function adds the <code>depth</code> -th element to stream and then forwards the stream and arguments to the next recursive call. Recursion stops when we've looped over the entire tuple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">depth</td><td>How deep in the recursion stack are we? </td></tr>
    <tr><td class="paramname">T</td><td>The type of the tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The stream to print <code>rhs</code> to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The tuple to print out. Each element of <code>rhs</code> must be printable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">odelim</td><td>The character to use for delimiting the beginning of the tuple. Defaults to <code>(</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cdelim</td><td>The character to use for denoting the end of the tuple. Defaults to <code>)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> containing <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if std::ostream&lt;&lt; throws. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
