<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: include/utilities/type_traits/tuple/tuple_utilities.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">utilities<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_52b4106b6168f13dcdf82e33b1d195ee.html">utilities</a></li><li class="navelem"><a class="el" href="dir_d05f3d15d7add73483003b88e408f339.html">type_traits</a></li><li class="navelem"><a class="el" href="dir_056bddfb3b7ee0659cec906174fd4f7e.html">tuple</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tuple_utilities.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;utilities/type_traits/type_traits_extensions.hpp&quot;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for tuple_utilities.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="tuple__utilities_8hpp__incl.png" border="0" usemap="#ainclude_2utilities_2type__traits_2tuple_2tuple__utilities_8hpp" alt=""/></div>
<map name="ainclude_2utilities_2type__traits_2tuple_2tuple__utilities_8hpp" id="ainclude_2utilities_2type__traits_2tuple_2tuple__utilities_8hpp">
<area shape="rect" title=" " alt="" coords="59,5,281,45"/>
<area shape="rect" href="type__traits__extensions_8hpp_source.html" title=" " alt="" coords="69,93,271,133"/>
<area shape="poly" title=" " alt="" coords="173,46,173,79,167,79,167,46"/>
<area shape="rect" title=" " alt="" coords="5,181,97,207"/>
<area shape="poly" title=" " alt="" coords="117,48,84,67,59,95,52,112,48,131,49,168,44,168,43,131,46,111,54,92,81,63,114,43"/>
<area shape="rect" title=" " alt="" coords="296,101,351,126"/>
<area shape="poly" title=" " alt="" coords="205,43,293,92,290,96,202,48"/>
<area shape="poly" title=" " alt="" coords="143,136,82,176,79,172,140,131"/>
<area shape="rect" title=" " alt="" coords="140,181,200,207"/>
<area shape="poly" title=" " alt="" coords="173,134,173,167,167,167,167,134"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="tuple__utilities_8hpp__dep__incl.png" border="0" usemap="#ainclude_2utilities_2type__traits_2tuple_2tuple__utilities_8hppdep" alt=""/></div>
<map name="ainclude_2utilities_2type__traits_2tuple_2tuple__utilities_8hppdep" id="ainclude_2utilities_2type__traits_2tuple_2tuple__utilities_8hppdep">
<area shape="rect" title=" " alt="" coords="5,5,227,45"/>
<area shape="rect" href="tuple_2tuple_8hpp_source.html" title=" " alt="" coords="33,93,199,133"/>
<area shape="poly" title=" " alt="" coords="119,59,119,93,113,93,113,59"/>
</map>
</div>
</div>
<p><a href="tuple__utilities_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutilities" id="r_namespaceutilities"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html">utilities</a></td></tr>
<tr class="memdesc:namespaceutilities"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for all functionality in the Utilities library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeddd9d8d94a6cf1bf6d30157da8b71c8" id="r_aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tuple__utilities_8hpp.html#aeddd9d8d94a6cf1bf6d30157da8b71c8">utilities::detail_::recursion_done</a> = std::is_same&lt; std::integral_constant&lt; std::size_t, I &gt;, std::integral_constant&lt; std::size_t, std::tuple_size&lt; std::decay_t&lt; tuple_type &gt; &gt;::value &gt; &gt;</td></tr>
<tr class="memdesc:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that will tell us if we have iterated over all elements of a tuple.  <br /></td></tr>
<tr class="separator:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23ecb9c53e5e2876bf8853de2b39298" id="r_ae23ecb9c53e5e2876bf8853de2b39298"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:ae23ecb9c53e5e2876bf8853de2b39298"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tuple__utilities_8hpp.html#ae23ecb9c53e5e2876bf8853de2b39298">utilities::detail_::recursion_not_done</a> = <a class="el" href="structutilities_1_1Negation.html">Negation</a>&lt; <a class="el" href="tuple__utilities_8hpp.html#aeddd9d8d94a6cf1bf6d30157da8b71c8">recursion_done</a>&lt; I, tuple_type &gt; &gt;</td></tr>
<tr class="memdesc:ae23ecb9c53e5e2876bf8853de2b39298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that will tell us if we are not done iterating over all elements of a tuple.  <br /></td></tr>
<tr class="separator:ae23ecb9c53e5e2876bf8853de2b39298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4199309c10a7c0c88f83d16fc58a9f48" id="r_a4199309c10a7c0c88f83d16fc58a9f48"><td class="memTemplParams" colspan="2"><a id="a4199309c10a7c0c88f83d16fc58a9f48" name="a4199309c10a7c0c88f83d16fc58a9f48"></a>
template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:a4199309c10a7c0c88f83d16fc58a9f48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::detail_::done_recursing</b> = std::enable_if&lt; <a class="el" href="tuple__utilities_8hpp.html#aeddd9d8d94a6cf1bf6d30157da8b71c8">recursion_done</a>&lt; I, tuple_type &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a4199309c10a7c0c88f83d16fc58a9f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a function via SFINAE if recursion through a tuple has finished. <br /></td></tr>
<tr class="separator:a4199309c10a7c0c88f83d16fc58a9f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352e0e0d09d4d05cb740d5d5b6b3175d" id="r_a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="memTemplParams" colspan="2"><a id="a352e0e0d09d4d05cb740d5d5b6b3175d" name="a352e0e0d09d4d05cb740d5d5b6b3175d"></a>
template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::detail_::recursing</b> = std::enable_if&lt; <a class="el" href="tuple__utilities_8hpp.html#ae23ecb9c53e5e2876bf8853de2b39298">recursion_not_done</a>&lt; I, tuple_type &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a function via SFINAE if recursion through a tuple is still going. <br /></td></tr>
<tr class="separator:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65f6b0b27eb811af5dfe47680247ea92" id="r_a65f6b0b27eb811af5dfe47680247ea92"><td class="memTemplParams" colspan="2"><a id="a65f6b0b27eb811af5dfe47680247ea92" name="a65f6b0b27eb811af5dfe47680247ea92"></a>
template&lt;typename tuple_type , typename functor_type , std::size_t... I&gt; </td></tr>
<tr class="memitem:a65f6b0b27eb811af5dfe47680247ea92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::detail_::tuple_transform_impl</b> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="memdesc:a65f6b0b27eb811af5dfe47680247ea92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually implements the tuple_transform function. <br /></td></tr>
<tr class="separator:a65f6b0b27eb811af5dfe47680247ea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5545286e54a5a7e81fd3d97d18aca72" id="r_ae5545286e54a5a7e81fd3d97d18aca72"><td class="memTemplParams" colspan="2"><a id="ae5545286e54a5a7e81fd3d97d18aca72" name="ae5545286e54a5a7e81fd3d97d18aca72"></a>
template&lt;typename lhs_type , typename rhs_type , typename functor_type , std::size_t... I&gt; </td></tr>
<tr class="memitem:ae5545286e54a5a7e81fd3d97d18aca72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::detail_::tuple_transform_impl</b> (lhs_type &amp;&amp;lhs, rhs_type &amp;&amp;rhs, functor_type &amp;&amp;functor, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="memdesc:ae5545286e54a5a7e81fd3d97d18aca72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The guts behind actually combining tuples via a functor. <br /></td></tr>
<tr class="separator:ae5545286e54a5a7e81fd3d97d18aca72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3758b4759605d7c6ca9bb4d5e69fdb57" id="r_a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename tuple_type , typename functor_type , typename return_type , typename <a class="el" href="tuple__utilities_8hpp.html#a4199309c10a7c0c88f83d16fc58a9f48">done_recursing</a>&lt; I, tuple_type &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tuple__utilities_8hpp.html#a3758b4759605d7c6ca9bb4d5e69fdb57">utilities::detail_::tuple_accumulate_impl</a> (tuple_type &amp;&amp;, functor_type &amp;&amp;, return_type val)</td></tr>
<tr class="memdesc:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">End-point for reducing a tuple.  <br /></td></tr>
<tr class="separator:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f6987dda064628345bbd90a6832f9" id="r_ab27f6987dda064628345bbd90a6832f9"><td class="memTemplParams" colspan="2"><a id="ab27f6987dda064628345bbd90a6832f9" name="ab27f6987dda064628345bbd90a6832f9"></a>
template&lt;std::size_t I, typename tuple_type , typename functor_type , typename <a class="el" href="tuple__utilities_8hpp.html#a4199309c10a7c0c88f83d16fc58a9f48">done_recursing</a>&lt; I, tuple_type &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab27f6987dda064628345bbd90a6832f9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::detail_::tuple_find_if_impl</b> (tuple_type &amp;&amp;t, functor_type &amp;&amp;functor)</td></tr>
<tr class="separator:ab27f6987dda064628345bbd90a6832f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2" id="r_ad027649c245bd7e411e2155305cef0b2"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ad027649c245bd7e411e2155305cef0b2">utilities::tuple_transform</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ad027649c245bd7e411e2155305cef0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple of objects this function will apply a functor to each of them and return the results as a tuple.  <br /></td></tr>
<tr class="separator:ad027649c245bd7e411e2155305cef0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc" id="r_ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplParams" colspan="2">template&lt;typename lhs_type , typename rhs_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ace8cac62cfa90cdf3463f1112b5b6bcc">utilities::tuple_transform</a> (lhs_type &amp;&amp;lhs, rhs_type &amp;&amp;rhs, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a binary operation two tuples returning the result.  <br /></td></tr>
<tr class="separator:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5" id="r_ae651021596ff36720a7654eb78fce2b5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type , typename return_type &gt; </td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae651021596ff36720a7654eb78fce2b5">utilities::tuple_accumulate</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor, return_type val)</td></tr>
<tr class="memdesc:ae651021596ff36720a7654eb78fce2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a reduction to a tuple.  <br /></td></tr>
<tr class="separator:ae651021596ff36720a7654eb78fce2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5" id="r_a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2be3eccba3a5a2e170aec27390a6d1d5">utilities::tuple_find_if</a> (tuple_type &amp;&amp;t, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a functor to each element of a tuple and returns the index of the tuple element for which the functor first evaluates to true.  <br /></td></tr>
<tr class="separator:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file collects a series of useful utilities for doing template meta-programming using tuples. Their actual definitions are a bit messy so it is highly recommended you consult their documentation or the tests to see how to use them. For the most part the algorithms in this file strive to emulate the STL container routines with similar names.</p>
<ul>
<li>tuple_transform: element-wise applies a unary/binary functor to a tuple/pair of tuples and collects the results in a new tuple</li>
<li>tuple_accumulate: applies a functor to each element of a tuple and accumulates the results in a single value</li>
<li>tuple_find_if: returns the first index of the tuple element for which a functor returns true </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aeddd9d8d94a6cf1bf6d30157da8b71c8" name="aeddd9d8d94a6cf1bf6d30157da8b71c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddd9d8d94a6cf1bf6d30157da8b71c8">&#9670;&#160;</a></span>recursion_done</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename tuple_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="tuple__utilities_8hpp.html#aeddd9d8d94a6cf1bf6d30157da8b71c8">utilities::detail_::recursion_done</a> = typedef std::is_same&lt; std::integral_constant&lt;std::size_t, I&gt;, std::integral_constant&lt;std::size_t, std::tuple_size&lt;std::decay_t&lt;tuple_type&gt; &gt;::value&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that will tell us if we have iterated over all elements of a tuple. </p>
<p>If <code>I</code> is the same as the number of elements in the tuple the resulting class will contain a bool member <code>value</code> set to true. Otherwise <code>value</code> will be set to false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The iteration number. </td></tr>
    <tr><td class="paramname">tuple_type</td><td>The type of the tuple we are iterating over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae23ecb9c53e5e2876bf8853de2b39298" name="ae23ecb9c53e5e2876bf8853de2b39298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23ecb9c53e5e2876bf8853de2b39298">&#9670;&#160;</a></span>recursion_not_done</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename tuple_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="tuple__utilities_8hpp.html#ae23ecb9c53e5e2876bf8853de2b39298">utilities::detail_::recursion_not_done</a> = typedef Negation&lt;recursion_done&lt;I, tuple_type&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that will tell us if we are not done iterating over all elements of a tuple. </p>
<p>If <code>I</code> is the same as the number of elements in the tuple the resulting class will contain a bool member <code>value</code> set to false. Otherwise <code>value</code> will be set to true.</p>
<dl class="section note"><dt>Note</dt><dd>One could negate the result of recursion_done instead of using this class; however, doing so results in the same type and can't be used for SFINAE.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The iteration number. </td></tr>
    <tr><td class="paramname">tuple_type</td><td>The type of the tuple we are iterating over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3758b4759605d7c6ca9bb4d5e69fdb57" name="a3758b4759605d7c6ca9bb4d5e69fdb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3758b4759605d7c6ca9bb4d5e69fdb57">&#9670;&#160;</a></span>tuple_accumulate_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename tuple_type , typename functor_type , typename return_type , typename done_recursing&lt; I, tuple_type &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type utilities::detail_::tuple_accumulate_impl </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">return_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End-point for reducing a tuple. </p>
<p>The guts of the recursive process for reducing a tuple. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
