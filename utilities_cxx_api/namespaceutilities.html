<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">utilities<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">utilities Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for all functionality in the Utilities library.  
<a href="namespaceutilities.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Conjunction.html">Conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the types are true too.  <a href="structutilities_1_1Conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Conjunction_3_01B1_01_4.html">Conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">Conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Enumerate.html">Enumerate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the elements in a container.  <a href="classutilities_1_1Enumerate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__arrow.html">has_arrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type has the arrow operator.  <a href="structutilities_1_1has__arrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__arrow_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_1declval_3_01Tc2e084b9cef720d782218e5746e3baf5.html">has_arrow&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;().operator-&gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__dereference.html">has_dereference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is dereference-able via the star operator.  <a href="structutilities_1_1has__dereference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__dereference_3_01T_00_01typename_01VoidType_3_01decltype_07_5std_1_1declvf530c08b2e833f04bbccaec8d005ee1a.html">has_dereference&lt; T, typename VoidType&lt; decltype(*std::declval&lt; T &gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__decrement.html">has_postfix_decrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the postfix decrement operator.  <a href="structutilities_1_1has__postfix__decrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__decrement_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_189de70649f76f38765574e30217d956d.html">has_postfix_decrement&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;() --)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__increment.html">has_postfix_increment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the postfix increment operator.  <a href="structutilities_1_1has__postfix__increment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__increment_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_10d94e0a57d4a324f9146bbcb393f1467.html">has_postfix_increment&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;()++)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__decrement.html">has_prefix_decrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the prefix decrement operator.  <a href="structutilities_1_1has__prefix__decrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__decrement_3_01T_00_01typename_01VoidType_3_01decltype_07--std_1_6eca0d7d721834388c670a1a20244a9f.html">has_prefix_decrement&lt; T, typename VoidType&lt; decltype(--std::declval&lt; T &gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__increment.html">has_prefix_increment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the prefix increment operator.  <a href="structutilities_1_1has__prefix__increment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__increment_3_01T_00_01typename_01VoidType_3_01decltype_07_09_09stf2cc41068d5dfe0687b63a3abe932aa2.html">has_prefix_increment&lt; T, typename VoidType&lt; decltype(++std::declval&lt; T &gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code factorization for a container that supports indexing.  <a href="classutilities_1_1IndexableContainerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "BidirectionalIterator".  <a href="structutilities_1_1is__bidirectional__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__container.html">is_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "Container".  <a href="structutilities_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__indexable.html">is_indexable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the index operator.  <a href="structutilities_1_1is__indexable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__indexable_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_1declval_3_e36cb9467602774b885ccc2b25a87a84.html">is_indexable&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;()[0])&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "InputIterator".  <a href="structutilities_1_1is__input__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "Iterator".  <a href="structutilities_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__random__access__iterator.html">is_random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "RandomAccessIterator".  <a href="structutilities_1_1is__random__access__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1MathSet.html">MathSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an std::unordered_set-like object except that it knows about union, etc.  <a href="classutilities_1_1MathSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Negation.html">Negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the member value to the opposite of the input value.  <a href="structutilities_1_1Negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a uniform API for accessing data regardless of whether it owns the data in it or aliases it.  <a href="classutilities_1_1OwnOrBorrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container that holds a range of integers.  <a href="classutilities_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates timing one or more functions.  <a href="classutilities_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1VoidType.html">VoidType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that is always void.  <a href="structutilities_1_1VoidType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Zip.html">Zip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container filled with elements resulting from zipping containers together.  <a href="classutilities_1_1Zip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a46b8e7ca5123e28b92af40ff0e5bf2b8" id="r_a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a46b8e7ca5123e28b92af40ff0e5bf2b8">CaseInsensitiveMap</a> = std::map&lt; std::string, T, <a class="el" href="structutilities_1_1detail___1_1CaseInsensitiveLess__.html">detail_::CaseInsensitiveLess_</a> &gt;</td></tr>
<tr class="memdesc:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A case-insensitive std::map (the keys are assumed to be std::string otherwise it doesn't make a whole lot of sense to do a case-insensitive compare...)  <br /></td></tr>
<tr class="separator:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476bf7a49a7f2af8f20b3ba5631e7379" id="r_a476bf7a49a7f2af8f20b3ba5631e7379"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a476bf7a49a7f2af8f20b3ba5631e7379">is_forward_iterator</a> = <a class="el" href="structutilities_1_1is__input__iterator.html">is_input_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "ForwardIterator".  <br /></td></tr>
<tr class="separator:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28d787819ccbe93afc46dfbe6f7f48e" id="r_ab28d787819ccbe93afc46dfbe6f7f48e"><td class="memTemplParams" colspan="2"><a id="ab28d787819ccbe93afc46dfbe6f7f48e" name="ab28d787819ccbe93afc46dfbe6f7f48e"></a>
template&lt;typename Base , typename Derived , typename U  = void&gt; </td></tr>
<tr class="memitem:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_base_of_t</b> = std::enable_if_t&lt; std::is_base_of_v&lt; Base, Derived &gt;, U &gt;</td></tr>
<tr class="memdesc:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for SFINAE enable-if checks on polymorphic types. <br /></td></tr>
<tr class="separator:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1886623539f2370f2775e1768913d0a4" id="r_a1886623539f2370f2775e1768913d0a4"><td class="memTemplParams" colspan="2"><a id="a1886623539f2370f2775e1768913d0a4" name="a1886623539f2370f2775e1768913d0a4"></a>
template&lt;typename Base , typename Derived , typename U  = void&gt; </td></tr>
<tr class="memitem:a1886623539f2370f2775e1768913d0a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_not_base_of_t</b> = std::enable_if_t&lt;!std::is_base_of_v&lt; Base, Derived &gt;, U &gt;</td></tr>
<tr class="separator:a1886623539f2370f2775e1768913d0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286981143c3710fa4b2625eaf09c93d7" id="r_a286981143c3710fa4b2625eaf09c93d7"><td class="memTemplParams" colspan="2"><a id="a286981143c3710fa4b2625eaf09c93d7" name="a286981143c3710fa4b2625eaf09c93d7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a286981143c3710fa4b2625eaf09c93d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variant_to_tuple_t</b> = typename <a class="el" href="structutilities_1_1detail___1_1variant__to__tuple.html">detail_::variant_to_tuple</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a286981143c3710fa4b2625eaf09c93d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API for getting the type of a tuple with the same types as a variant. <br /></td></tr>
<tr class="separator:a286981143c3710fa4b2625eaf09c93d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d951289c4ed72cc21f51b6e155b3ada" id="r_a6d951289c4ed72cc21f51b6e155b3ada"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d951289c4ed72cc21f51b6e155b3ada"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6d951289c4ed72cc21f51b6e155b3ada">operator==</a> (const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6d951289c4ed72cc21f51b6e155b3ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing the same value.  <br /></td></tr>
<tr class="separator:a6d951289c4ed72cc21f51b6e155b3ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc6f7209b2dea2952d12fb74afbb951" id="r_afdc6f7209b2dea2952d12fb74afbb951"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afdc6f7209b2dea2952d12fb74afbb951"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#afdc6f7209b2dea2952d12fb74afbb951">operator!=</a> (const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:afdc6f7209b2dea2952d12fb74afbb951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing different values.  <br /></td></tr>
<tr class="separator:afdc6f7209b2dea2952d12fb74afbb951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ac2baf94042546477c66897958c543" id="r_aa0ac2baf94042546477c66897958c543"><td class="memTemplParams" colspan="2"><a id="aa0ac2baf94042546477c66897958c543" name="aa0ac2baf94042546477c66897958c543"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa0ac2baf94042546477c66897958c543"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Enumerate</b> (Args &amp;&amp;...) -&gt; <a class="el" href="classutilities_1_1Enumerate.html">Enumerate</a>&lt; Args... &gt;</td></tr>
<tr class="separator:aa0ac2baf94042546477c66897958c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac693feb6291b7e307d51dba6332796fc" id="r_ac693feb6291b7e307d51dba6332796fc"><td class="memTemplParams" colspan="2"><a id="ac693feb6291b7e307d51dba6332796fc" name="ac693feb6291b7e307d51dba6332796fc"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac693feb6291b7e307d51dba6332796fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Zip</b> (Args &amp;&amp;...) -&gt; <a class="el" href="classutilities_1_1Zip.html">Zip</a>&lt; Args... &gt;</td></tr>
<tr class="separator:ac693feb6291b7e307d51dba6332796fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b618bb285899fe732d71484c6698b62" id="r_a3b618bb285899fe732d71484c6698b62"><td class="memTemplParams" colspan="2">template&lt;typename SignedType  = long, typename UnsignedType  = std::size_t&gt; </td></tr>
<tr class="memitem:a3b618bb285899fe732d71484c6698b62"><td class="memTemplItemLeft" align="right" valign="top">SignedType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a3b618bb285899fe732d71484c6698b62">UnsignedSubtract</a> (const UnsignedType &amp;lhs, const UnsignedType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3b618bb285899fe732d71484c6698b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two integer type instances this function will take their difference in a manner that will not lead to an overflow and will generate the correct sign on the result.  <br /></td></tr>
<tr class="separator:a3b618bb285899fe732d71484c6698b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083b368752e42ae3c5628d9505b7d3df" id="r_a083b368752e42ae3c5628d9505b7d3df"><td class="memItemLeft" align="right" valign="top"><a id="a083b368752e42ae3c5628d9505b7d3df" name="a083b368752e42ae3c5628d9505b7d3df"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classutilities_1_1Timer.html">Timer</a> &amp;t)</td></tr>
<tr class="separator:a083b368752e42ae3c5628d9505b7d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2" id="r_ad027649c245bd7e411e2155305cef0b2"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ad027649c245bd7e411e2155305cef0b2">tuple_transform</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ad027649c245bd7e411e2155305cef0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple of objects this function will apply a functor to each of them and return the results as a tuple.  <br /></td></tr>
<tr class="separator:ad027649c245bd7e411e2155305cef0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc" id="r_ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplParams" colspan="2">template&lt;typename lhs_type , typename rhs_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ace8cac62cfa90cdf3463f1112b5b6bcc">tuple_transform</a> (lhs_type &amp;&amp;lhs, rhs_type &amp;&amp;rhs, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a binary operation two tuples returning the result.  <br /></td></tr>
<tr class="separator:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5" id="r_ae651021596ff36720a7654eb78fce2b5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type , typename return_type &gt; </td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae651021596ff36720a7654eb78fce2b5">tuple_accumulate</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor, return_type val)</td></tr>
<tr class="memdesc:ae651021596ff36720a7654eb78fce2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a reduction to a tuple.  <br /></td></tr>
<tr class="separator:ae651021596ff36720a7654eb78fce2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5" id="r_a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2be3eccba3a5a2e170aec27390a6d1d5">tuple_find_if</a> (tuple_type &amp;&amp;t, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a functor to each element of a tuple and returns the index of the tuple element for which the functor first evaluates to true.  <br /></td></tr>
<tr class="separator:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de73b0e095732a1f51cf33e9029bcbc" id="r_a1de73b0e095732a1f51cf33e9029bcbc"><td class="memItemLeft" align="right" valign="top"><a id="a1de73b0e095732a1f51cf33e9029bcbc" name="a1de73b0e095732a1f51cf33e9029bcbc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (value_type)</td></tr>
<tr class="separator:a1de73b0e095732a1f51cf33e9029bcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0959be3c1675d30232c9c97c3d659ce9" id="r_a0959be3c1675d30232c9c97c3d659ce9"><td class="memItemLeft" align="right" valign="top"><a id="a0959be3c1675d30232c9c97c3d659ce9" name="a0959be3c1675d30232c9c97c3d659ce9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (reference)</td></tr>
<tr class="separator:a0959be3c1675d30232c9c97c3d659ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a41b63afd2cbe0f931a8049c8b78213" id="r_a9a41b63afd2cbe0f931a8049c8b78213"><td class="memItemLeft" align="right" valign="top"><a id="a9a41b63afd2cbe0f931a8049c8b78213" name="a9a41b63afd2cbe0f931a8049c8b78213"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (const_reference)</td></tr>
<tr class="separator:a9a41b63afd2cbe0f931a8049c8b78213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9781d3420bf558939c3dc3d55597e0" id="r_a2e9781d3420bf558939c3dc3d55597e0"><td class="memItemLeft" align="right" valign="top"><a id="a2e9781d3420bf558939c3dc3d55597e0" name="a2e9781d3420bf558939c3dc3d55597e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (pointer)</td></tr>
<tr class="separator:a2e9781d3420bf558939c3dc3d55597e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedc2b2657b719924ce7417bf5a00e84" id="r_abedc2b2657b719924ce7417bf5a00e84"><td class="memItemLeft" align="right" valign="top"><a id="abedc2b2657b719924ce7417bf5a00e84" name="abedc2b2657b719924ce7417bf5a00e84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (const_pointer)</td></tr>
<tr class="separator:abedc2b2657b719924ce7417bf5a00e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e33945884b43b6494a3771aa38e048" id="r_a28e33945884b43b6494a3771aa38e048"><td class="memItemLeft" align="right" valign="top"><a id="a28e33945884b43b6494a3771aa38e048" name="a28e33945884b43b6494a3771aa38e048"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (iterator)</td></tr>
<tr class="separator:a28e33945884b43b6494a3771aa38e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8aa146d8f94edbc2b7719c34c8a757" id="r_a4c8aa146d8f94edbc2b7719c34c8a757"><td class="memItemLeft" align="right" valign="top"><a id="a4c8aa146d8f94edbc2b7719c34c8a757" name="a4c8aa146d8f94edbc2b7719c34c8a757"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (const_iterator)</td></tr>
<tr class="separator:a4c8aa146d8f94edbc2b7719c34c8a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d0e66972a381fffe2edd6df540819b" id="r_ac0d0e66972a381fffe2edd6df540819b"><td class="memItemLeft" align="right" valign="top"><a id="ac0d0e66972a381fffe2edd6df540819b" name="ac0d0e66972a381fffe2edd6df540819b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (difference_type)</td></tr>
<tr class="separator:ac0d0e66972a381fffe2edd6df540819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0ccffa75ca8b36537df615680e23d" id="r_a16a0ccffa75ca8b36537df615680e23d"><td class="memItemLeft" align="right" valign="top"><a id="a16a0ccffa75ca8b36537df615680e23d" name="a16a0ccffa75ca8b36537df615680e23d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (size_type)</td></tr>
<tr class="separator:a16a0ccffa75ca8b36537df615680e23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d28ce9a8922970bd1ad0e26c406579" id="r_a04d28ce9a8922970bd1ad0e26c406579"><td class="memItemLeft" align="right" valign="top"><a id="a04d28ce9a8922970bd1ad0e26c406579" name="a04d28ce9a8922970bd1ad0e26c406579"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (iterator_category)</td></tr>
<tr class="separator:a04d28ce9a8922970bd1ad0e26c406579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd1bd377922c8368a161ebbe959afda" id="r_a1bd1bd377922c8368a161ebbe959afda"><td class="memItemLeft" align="right" valign="top"><a id="a1bd1bd377922c8368a161ebbe959afda" name="a1bd1bd377922c8368a161ebbe959afda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (begin)</td></tr>
<tr class="separator:a1bd1bd377922c8368a161ebbe959afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ef354093c3c6cc373b820d54e1399" id="r_a5b8ef354093c3c6cc373b820d54e1399"><td class="memItemLeft" align="right" valign="top"><a id="a5b8ef354093c3c6cc373b820d54e1399" name="a5b8ef354093c3c6cc373b820d54e1399"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (end)</td></tr>
<tr class="separator:a5b8ef354093c3c6cc373b820d54e1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba3328ed7c67661c4b752e568a92273" id="r_a8ba3328ed7c67661c4b752e568a92273"><td class="memItemLeft" align="right" valign="top"><a id="a8ba3328ed7c67661c4b752e568a92273" name="a8ba3328ed7c67661c4b752e568a92273"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (cbegin)</td></tr>
<tr class="separator:a8ba3328ed7c67661c4b752e568a92273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bce201beb02cf59a562411366a8abb" id="r_aa1bce201beb02cf59a562411366a8abb"><td class="memItemLeft" align="right" valign="top"><a id="aa1bce201beb02cf59a562411366a8abb" name="aa1bce201beb02cf59a562411366a8abb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (cend)</td></tr>
<tr class="separator:aa1bce201beb02cf59a562411366a8abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4153948623b6b55dd5f3b4fe1ed315dc" id="r_a4153948623b6b55dd5f3b4fe1ed315dc"><td class="memItemLeft" align="right" valign="top"><a id="a4153948623b6b55dd5f3b4fe1ed315dc" name="a4153948623b6b55dd5f3b4fe1ed315dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (size)</td></tr>
<tr class="separator:a4153948623b6b55dd5f3b4fe1ed315dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d068120b5f2e0c3afff366418f4fd92" id="r_a1d068120b5f2e0c3afff366418f4fd92"><td class="memItemLeft" align="right" valign="top"><a id="a1d068120b5f2e0c3afff366418f4fd92" name="a1d068120b5f2e0c3afff366418f4fd92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (max_size)</td></tr>
<tr class="separator:a1d068120b5f2e0c3afff366418f4fd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acb5f62a5fed8b0148b69c47ffc5b54" id="r_a7acb5f62a5fed8b0148b69c47ffc5b54"><td class="memItemLeft" align="right" valign="top"><a id="a7acb5f62a5fed8b0148b69c47ffc5b54" name="a7acb5f62a5fed8b0148b69c47ffc5b54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (empty)</td></tr>
<tr class="separator:a7acb5f62a5fed8b0148b69c47ffc5b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8261f31c0640adbb4403bcb4725d7d85" id="r_a8261f31c0640adbb4403bcb4725d7d85"><td class="memItemLeft" align="right" valign="top"><a id="a8261f31c0640adbb4403bcb4725d7d85" name="a8261f31c0640adbb4403bcb4725d7d85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (equal_to,==)</td></tr>
<tr class="separator:a8261f31c0640adbb4403bcb4725d7d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3599a334237fc470a26d159d1f305462" id="r_a3599a334237fc470a26d159d1f305462"><td class="memItemLeft" align="right" valign="top"><a id="a3599a334237fc470a26d159d1f305462" name="a3599a334237fc470a26d159d1f305462"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (not_equal_to, !=)</td></tr>
<tr class="separator:a3599a334237fc470a26d159d1f305462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffd09e4777f575b181ee8859cde20af" id="r_aeffd09e4777f575b181ee8859cde20af"><td class="memItemLeft" align="right" valign="top"><a id="aeffd09e4777f575b181ee8859cde20af" name="aeffd09e4777f575b181ee8859cde20af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (less_than,&lt;)</td></tr>
<tr class="separator:aeffd09e4777f575b181ee8859cde20af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5246334e6e9a4d266fe1e68082af2565" id="r_a5246334e6e9a4d266fe1e68082af2565"><td class="memItemLeft" align="right" valign="top"><a id="a5246334e6e9a4d266fe1e68082af2565" name="a5246334e6e9a4d266fe1e68082af2565"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (greater_than, &gt;)</td></tr>
<tr class="separator:a5246334e6e9a4d266fe1e68082af2565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2320f5df7da61e824ea69d3e07ff19bb" id="r_a2320f5df7da61e824ea69d3e07ff19bb"><td class="memItemLeft" align="right" valign="top"><a id="a2320f5df7da61e824ea69d3e07ff19bb" name="a2320f5df7da61e824ea69d3e07ff19bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (less_than_equal,&lt;=)</td></tr>
<tr class="separator:a2320f5df7da61e824ea69d3e07ff19bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b42d8995d43b4cf1dee9f57ae1e20" id="r_a664b42d8995d43b4cf1dee9f57ae1e20"><td class="memItemLeft" align="right" valign="top"><a id="a664b42d8995d43b4cf1dee9f57ae1e20" name="a664b42d8995d43b4cf1dee9f57ae1e20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (greater_than_equal, &gt;=)</td></tr>
<tr class="separator:a664b42d8995d43b4cf1dee9f57ae1e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39196a1f8fb92e2fc7f5eb372fe1bec2" id="r_a39196a1f8fb92e2fc7f5eb372fe1bec2"><td class="memItemLeft" align="right" valign="top"><a id="a39196a1f8fb92e2fc7f5eb372fe1bec2" name="a39196a1f8fb92e2fc7f5eb372fe1bec2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (increment_by,+=)</td></tr>
<tr class="separator:a39196a1f8fb92e2fc7f5eb372fe1bec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c91685f9c5c8e5249376d4c285ed8fc" id="r_a8c91685f9c5c8e5249376d4c285ed8fc"><td class="memItemLeft" align="right" valign="top"><a id="a8c91685f9c5c8e5249376d4c285ed8fc" name="a8c91685f9c5c8e5249376d4c285ed8fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (decrement_by, -=)</td></tr>
<tr class="separator:a8c91685f9c5c8e5249376d4c285ed8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf160be7609dae1dd302bb0a4800c6dc" id="r_aaf160be7609dae1dd302bb0a4800c6dc"><td class="memItemLeft" align="right" valign="top"><a id="aaf160be7609dae1dd302bb0a4800c6dc" name="aaf160be7609dae1dd302bb0a4800c6dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (plus,+)</td></tr>
<tr class="separator:aaf160be7609dae1dd302bb0a4800c6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa422aac1f94e9c12228369fe5aa5c8ab" id="r_aa422aac1f94e9c12228369fe5aa5c8ab"><td class="memItemLeft" align="right" valign="top"><a id="aa422aac1f94e9c12228369fe5aa5c8ab" name="aa422aac1f94e9c12228369fe5aa5c8ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (minus, -)</td></tr>
<tr class="separator:aa422aac1f94e9c12228369fe5aa5c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all functionality in the Utilities library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a46b8e7ca5123e28b92af40ff0e5bf2b8" name="a46b8e7ca5123e28b92af40ff0e5bf2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b8e7ca5123e28b92af40ff0e5bf2b8">&#9670;&#160;</a></span>CaseInsensitiveMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutilities.html#a46b8e7ca5123e28b92af40ff0e5bf2b8">utilities::CaseInsensitiveMap</a> = typedef std::map&lt;std::string, T, <a class="el" href="structutilities_1_1detail___1_1CaseInsensitiveLess__.html">detail_::CaseInsensitiveLess_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A case-insensitive std::map (the keys are assumed to be std::string otherwise it doesn't make a whole lot of sense to do a case-insensitive compare...) </p>
<p>This class is really just a partial specialization of std::map so it's API is simply that of std::map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of values you are putting into the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a476bf7a49a7f2af8f20b3ba5631e7379" name="a476bf7a49a7f2af8f20b3ba5631e7379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476bf7a49a7f2af8f20b3ba5631e7379">&#9670;&#160;</a></span>is_forward_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutilities.html#a476bf7a49a7f2af8f20b3ba5631e7379">utilities::is_forward_iterator</a> = typedef <a class="el" href="structutilities_1_1is__input__iterator.html">is_input_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This struct will contain a value true if the type satisfies the C++ concept of "ForwardIterator". </p>
<dl class="section note"><dt>Note</dt><dd>A forward iterator is just an input iterator with a multipass guarantee. We currently are not checking for this hence this struct is only a typedef for clarity.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This type will not check if the type is swappable. A type_trait, is_swappable exists in C++17 for this purpose. Implementing our own is a royal pain on account of how the STL actually does swapping...</dd></dl>
<p>The full specificiation of what an "forward iterator" must have is available &lt; a href="http://en.cppreference.com/w/cpp/concept/ForwardIterator"&gt;here. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afdc6f7209b2dea2952d12fb74afbb951" name="afdc6f7209b2dea2952d12fb74afbb951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc6f7209b2dea2952d12fb74afbb951">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing different values. </p>
<p>This function compares the managed values using operator== and negates the result. In particular this means we are not determining if the two instances are aliasing different instances only that the values compare different.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the managed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the comparison operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance <code>lhs</code> is being compared to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if T::operator== returns true and true if T::operator== returns false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if T::operator== throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d951289c4ed72cc21f51b6e155b3ada" name="a6d951289c4ed72cc21f51b6e155b3ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d951289c4ed72cc21f51b6e155b3ada">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing the same value. </p>
<p>This function compares the managed values using operator== and returns the result. In particular this means we are not determining if the two instances are aliasing the same instance, only that the values compare equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the managed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the comparison operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance <code>lhs</code> is being compared to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if T::operator== returns true and false if T::operator== returns false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if T::operator== throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae651021596ff36720a7654eb78fce2b5" name="ae651021596ff36720a7654eb78fce2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae651021596ff36720a7654eb78fce2b5">&#9670;&#160;</a></span>tuple_accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tuple_type , typename functor_type , typename return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type utilities::tuple_accumulate </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">return_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a reduction to a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>The tuple to reduce </td></tr>
    <tr><td class="paramname">functor</td><td>The functor instance to use to do the reduction </td></tr>
    <tr><td class="paramname">val</td><td>The initial value for the reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value resulting from reducing all elements of the tuple</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tuple_type</td><td>The type of the tuple we are reducing</td></tr>
    <tr><td class="paramname">functor_type</td><td>The type of the functor doing the reduction. Must define a member() with the signature: <div class="fragment"><div class="line"><span class="comment">//Applies the functor to a tuple element combining it</span></div>
<div class="line"><span class="comment">//param sum is the current reduction total</span></div>
<div class="line"><span class="comment">//param element is the element to reduce into sum</span></div>
<div class="line"><span class="comment">//return is the result of reducing sum and element</span></div>
<div class="line">return_type operator()(return_type sum, tuple_element element);</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">return_type</td><td>The type resulting from a reduction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if any application of the functor to the tuple throws. Throw guarantee is same as that of functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be3eccba3a5a2e170aec27390a6d1d5" name="a2be3eccba3a5a2e170aec27390a6d1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be3eccba3a5a2e170aec27390a6d1d5">&#9670;&#160;</a></span>tuple_find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tuple_type , typename functor_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t utilities::tuple_find_if </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a functor to each element of a tuple and returns the index of the tuple element for which the functor first evaluates to true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tuple_type</td><td>The type of the tuple. </td></tr>
    <tr><td class="paramname">functor_type</td><td>The type of a unary functor used to "select" an element of the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tuple. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor instance to apply to each element of the tuple. Should define a member function bool operator()(T&amp;&amp;) which will be called for the evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index for which the functor first evaluates to true or the size of the tuple if no entry evaluates to true. </dd></dl>

</div>
</div>
<a id="ace8cac62cfa90cdf3463f1112b5b6bcc" name="ace8cac62cfa90cdf3463f1112b5b6bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8cac62cfa90cdf3463f1112b5b6bcc">&#9670;&#160;</a></span>tuple_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename lhs_type , typename rhs_type , typename functor_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto utilities::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">lhs_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rhs_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a binary operation two tuples returning the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">lhs_type</td><td>The type of the tuple on the left of the operation. </td></tr>
    <tr><td class="paramname">rhs_type</td><td>The type of the tuple on the right of the operation. </td></tr>
    <tr><td class="paramname">functor_type</td><td>They type of the binary operation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The tuple on the left. </td></tr>
    <tr><td class="paramname">rhs</td><td>The tuple on the right. </td></tr>
    <tr><td class="paramname">functor</td><td>The actual functor instance to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple whose <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$i$" src="form_4.png"/></picture>-th element contains the result of applying <code>functor</code> to the <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$i$" src="form_4.png"/></picture>-th element of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a id="ad027649c245bd7e411e2155305cef0b2" name="ad027649c245bd7e411e2155305cef0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad027649c245bd7e411e2155305cef0b2">&#9670;&#160;</a></span>tuple_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tuple_type , typename functor_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto utilities::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tuple of objects this function will apply a functor to each of them and return the results as a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>The tuple to apply the functor to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functor</td><td>An instance of the functor to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tuple_type</td><td>The type of the std::tuple we are applying a functor to. </td></tr>
    <tr><td class="paramname">functor_type</td><td>The type of the functor we are applying to the tuple. The functor's operator() must be take a single argument, which will be one of the tuple's elements (hence for tuples with hetrogenous types, it must be templated on the input type). Hint: one can use auto as the return type to avoid having to do additional template meta-programming. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b618bb285899fe732d71484c6698b62" name="a3b618bb285899fe732d71484c6698b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b618bb285899fe732d71484c6698b62">&#9670;&#160;</a></span>UnsignedSubtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignedType  = long, typename UnsignedType  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SignedType utilities::UnsignedSubtract </td>
          <td>(</td>
          <td class="paramtype">const UnsignedType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two integer type instances this function will take their difference in a manner that will not lead to an overflow and will generate the correct sign on the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SignedType</td><td>The type of the result. Should be a signed integral POD type. </td></tr>
    <tr><td class="paramname">UnsignedType</td><td>The type of the input values. Should be an unsigned integral POD type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The number of the left of the minus sign. </td></tr>
    <tr><td class="paramname">rhs</td><td>The number on the right of the minus sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed difference between <code>lhs</code> and <code>rhs</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
