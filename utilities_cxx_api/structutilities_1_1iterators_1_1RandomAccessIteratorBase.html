<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: utilities::iterators::RandomAccessIteratorBase&lt; ParentType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">utilities<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceutilities.html">utilities</a></li><li class="navelem"><b>iterators</b></li><li class="navelem"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structutilities_1_1iterators_1_1RandomAccessIteratorBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">utilities::iterators::RandomAccessIteratorBase&lt; ParentType &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class is designed to facilitate making your own random access iterator class.  
 <a href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="random__access__iterator__base_8hpp_source.html">random_access_iterator_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for utilities::iterators::RandomAccessIteratorBase&lt; ParentType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structutilities_1_1iterators_1_1RandomAccessIteratorBase__inherit__graph.png" border="0" usemap="#autilities_1_1iterators_1_1RandomAccessIteratorBase_3_01ParentType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="autilities_1_1iterators_1_1RandomAccessIteratorBase_3_01ParentType_01_4_inherit__map" id="autilities_1_1iterators_1_1RandomAccessIteratorBase_3_01ParentType_01_4_inherit__map">
<area shape="rect" title="This class is designed to facilitate making your own random access iterator class." alt="" coords="5,211,215,265"/>
<area shape="rect" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html" title="This class is designed to facilitate making your own bidirectional iterator class." alt="" coords="14,108,206,163"/>
<area shape="poly" title=" " alt="" coords="113,176,113,211,107,211,107,176"/>
<area shape="rect" href="classutilities_1_1iterators_1_1InputIteratorBase.html" title="This class is designed to facilitate making your own input iterator class." alt="" coords="33,5,187,60"/>
<area shape="poly" title=" " alt="" coords="113,74,113,108,107,108,107,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for utilities::iterators::RandomAccessIteratorBase&lt; ParentType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structutilities_1_1iterators_1_1RandomAccessIteratorBase__coll__graph.png" border="0" usemap="#autilities_1_1iterators_1_1RandomAccessIteratorBase_3_01ParentType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="autilities_1_1iterators_1_1RandomAccessIteratorBase_3_01ParentType_01_4_coll__map" id="autilities_1_1iterators_1_1RandomAccessIteratorBase_3_01ParentType_01_4_coll__map">
<area shape="rect" title="This class is designed to facilitate making your own random access iterator class." alt="" coords="5,211,215,265"/>
<area shape="rect" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html" title="This class is designed to facilitate making your own bidirectional iterator class." alt="" coords="14,108,206,163"/>
<area shape="poly" title=" " alt="" coords="113,176,113,211,107,211,107,176"/>
<area shape="rect" href="classutilities_1_1iterators_1_1InputIteratorBase.html" title="This class is designed to facilitate making your own input iterator class." alt="" coords="33,5,187,60"/>
<area shape="poly" title=" " alt="" coords="113,74,113,108,107,108,107,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a025ee035e41470b798ea9c9c67cfb434" id="r_a025ee035e41470b798ea9c9c67cfb434"><td class="memItemLeft" align="right" valign="top"><a id="a025ee035e41470b798ea9c9c67cfb434" name="a025ee035e41470b798ea9c9c67cfb434"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_category</b> = std::random_access_iterator_tag</td></tr>
<tr class="memdesc:a025ee035e41470b798ea9c9c67cfb434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that this iterator is a random access iterator for TMP. <br /></td></tr>
<tr class="separator:a025ee035e41470b798ea9c9c67cfb434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structutilities_1_1iterators_1_1BidirectionalIteratorBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html">utilities::iterators::BidirectionalIteratorBase&lt; ParentType &gt;</a></td></tr>
<tr class="memitem:a9a03658c984b8d08304ed9a9d1953c97 inherit pub_types_structutilities_1_1iterators_1_1BidirectionalIteratorBase" id="r_a9a03658c984b8d08304ed9a9d1953c97"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_category</b> = std::bidirectional_iterator_tag</td></tr>
<tr class="memdesc:a9a03658c984b8d08304ed9a9d1953c97 inherit pub_types_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The category of iterator that this iterator satisfies. <br /></td></tr>
<tr class="separator:a9a03658c984b8d08304ed9a9d1953c97 inherit pub_types_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classutilities_1_1iterators_1_1InputIteratorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classutilities_1_1iterators_1_1InputIteratorBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html">utilities::iterators::InputIteratorBase&lt; ParentType &gt;</a></td></tr>
<tr class="memitem:aae4b7bd1855d9b5e7af04742bd0e7f15 inherit pub_types_classutilities_1_1iterators_1_1InputIteratorBase" id="r_aae4b7bd1855d9b5e7af04742bd0e7f15"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_category</b> = std::input_iterator_tag</td></tr>
<tr class="memdesc:aae4b7bd1855d9b5e7af04742bd0e7f15 inherit pub_types_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept tag this iterator obeys. <br /></td></tr>
<tr class="separator:aae4b7bd1855d9b5e7af04742bd0e7f15 inherit pub_types_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aba40fa49994cd5db57e6c6237030261a" id="r_aba40fa49994cd5db57e6c6237030261a"><td class="memTemplParams" colspan="2">template&lt;typename DifferenceType &gt; </td></tr>
<tr class="memitem:aba40fa49994cd5db57e6c6237030261a"><td class="memTemplItemLeft" align="right" valign="top">ParentType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#aba40fa49994cd5db57e6c6237030261a">operator+=</a> (DifferenceType &amp;&amp;n)</td></tr>
<tr class="memdesc:aba40fa49994cd5db57e6c6237030261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the current iterator the specified number of iterations.  <br /></td></tr>
<tr class="separator:aba40fa49994cd5db57e6c6237030261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942223007a00a9ecadae2bc818fb1885" id="r_a942223007a00a9ecadae2bc818fb1885"><td class="memTemplParams" colspan="2">template&lt;typename DifferenceType &gt; </td></tr>
<tr class="memitem:a942223007a00a9ecadae2bc818fb1885"><td class="memTemplItemLeft" align="right" valign="top">ParentType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#a942223007a00a9ecadae2bc818fb1885">operator+</a> (DifferenceType n) const</td></tr>
<tr class="memdesc:a942223007a00a9ecadae2bc818fb1885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the current iterator that points to the element a specified number of iterations away.  <br /></td></tr>
<tr class="separator:a942223007a00a9ecadae2bc818fb1885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7b8026a2e379f3710f7c8c7323a065" id="r_a4c7b8026a2e379f3710f7c8c7323a065"><td class="memTemplParams" colspan="2">template&lt;typename DifferenceType &gt; </td></tr>
<tr class="memitem:a4c7b8026a2e379f3710f7c8c7323a065"><td class="memTemplItemLeft" align="right" valign="top">ParentType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#a4c7b8026a2e379f3710f7c8c7323a065">operator-=</a> (DifferenceType n)</td></tr>
<tr class="memdesc:a4c7b8026a2e379f3710f7c8c7323a065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreats the current iterator the specified number of iterations.  <br /></td></tr>
<tr class="separator:a4c7b8026a2e379f3710f7c8c7323a065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6031b56177492011b29ebe8e37752ad1" id="r_a6031b56177492011b29ebe8e37752ad1"><td class="memTemplParams" colspan="2">template&lt;typename DifferenceType &gt; </td></tr>
<tr class="memitem:a6031b56177492011b29ebe8e37752ad1"><td class="memTemplItemLeft" align="right" valign="top">ParentType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#a6031b56177492011b29ebe8e37752ad1">operator-</a> (DifferenceType n) const</td></tr>
<tr class="memdesc:a6031b56177492011b29ebe8e37752ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the current iterator that points to the element a specified number of iterations away.  <br /></td></tr>
<tr class="separator:a6031b56177492011b29ebe8e37752ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682164d8a32b3af409f7b8bf567dfdff" id="r_a682164d8a32b3af409f7b8bf567dfdff"><td class="memTemplParams" colspan="2">template&lt;typename DifferenceType &gt; </td></tr>
<tr class="memitem:a682164d8a32b3af409f7b8bf567dfdff"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#a682164d8a32b3af409f7b8bf567dfdff">operator[]</a> (DifferenceType n) const</td></tr>
<tr class="memdesc:a682164d8a32b3af409f7b8bf567dfdff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides random access to any element in the container relative to the element currently pointed to by this iterator.  <br /></td></tr>
<tr class="separator:a682164d8a32b3af409f7b8bf567dfdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6fbc89f1128ab11a902b5cf7632b19" id="r_a1a6fbc89f1128ab11a902b5cf7632b19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#a1a6fbc89f1128ab11a902b5cf7632b19">operator&lt;</a> (const ParentType &amp;rhs) const</td></tr>
<tr class="memdesc:a1a6fbc89f1128ab11a902b5cf7632b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two iterators and returns true if the current iterator points to an element appearing earlier in the container.  <br /></td></tr>
<tr class="separator:a1a6fbc89f1128ab11a902b5cf7632b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff09b242f7e573c872a6ae1a80b07a5" id="r_afff09b242f7e573c872a6ae1a80b07a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#afff09b242f7e573c872a6ae1a80b07a5">operator&lt;=</a> (const ParentType &amp;rhs) const</td></tr>
<tr class="memdesc:afff09b242f7e573c872a6ae1a80b07a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two iterators and returns true if the current iterator points to an element appearing earlier in the container or if the two iterators point to the same element.  <br /></td></tr>
<tr class="separator:afff09b242f7e573c872a6ae1a80b07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a702be4c438d46627aec5b85ca1764" id="r_ab5a702be4c438d46627aec5b85ca1764"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#ab5a702be4c438d46627aec5b85ca1764">operator&gt;</a> (const ParentType &amp;rhs) const</td></tr>
<tr class="memdesc:ab5a702be4c438d46627aec5b85ca1764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two iterators and returns true if this iterator points to an element later in the container than the rhs iterator.  <br /></td></tr>
<tr class="separator:ab5a702be4c438d46627aec5b85ca1764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5facaf63677a629947a64f2cf5307257" id="r_a5facaf63677a629947a64f2cf5307257"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#a5facaf63677a629947a64f2cf5307257">operator&gt;=</a> (const ParentType &amp;rhs) const</td></tr>
<tr class="memdesc:a5facaf63677a629947a64f2cf5307257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two iterators and returns true if they point to the same element, or if the element pointed to by this iterator occurs later in the sequence than that of the rhs iterator.  <br /></td></tr>
<tr class="separator:a5facaf63677a629947a64f2cf5307257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29b36038a32711d0aeb8e5487aca261" id="r_af29b36038a32711d0aeb8e5487aca261"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html#af29b36038a32711d0aeb8e5487aca261">operator-</a> (const ParentType &amp;rhs) const</td></tr>
<tr class="memdesc:af29b36038a32711d0aeb8e5487aca261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between this iterator and another iterator.  <br /></td></tr>
<tr class="separator:af29b36038a32711d0aeb8e5487aca261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html">utilities::iterators::BidirectionalIteratorBase&lt; ParentType &gt;</a></td></tr>
<tr class="memitem:a5a89d4107f39a8242e262027f6763d26 inherit pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase" id="r_a5a89d4107f39a8242e262027f6763d26"><td class="memItemLeft" align="right" valign="top">ParentType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html#a5a89d4107f39a8242e262027f6763d26">operator--</a> ()</td></tr>
<tr class="memdesc:a5a89d4107f39a8242e262027f6763d26 inherit pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this iterator pointing to the previous element.  <br /></td></tr>
<tr class="separator:a5a89d4107f39a8242e262027f6763d26 inherit pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec28afe53d3bc552a78393d3fe2475 inherit pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase" id="r_abbec28afe53d3bc552a78393d3fe2475"><td class="memItemLeft" align="right" valign="top">ParentType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html#abbec28afe53d3bc552a78393d3fe2475">operator--</a> (int)</td></tr>
<tr class="memdesc:abbec28afe53d3bc552a78393d3fe2475 inherit pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the current iterator after returning the value.  <br /></td></tr>
<tr class="separator:abbec28afe53d3bc552a78393d3fe2475 inherit pub_methods_structutilities_1_1iterators_1_1BidirectionalIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classutilities_1_1iterators_1_1InputIteratorBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html">utilities::iterators::InputIteratorBase&lt; ParentType &gt;</a></td></tr>
<tr class="memitem:a67887375afa9b87866104079daade187 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_a67887375afa9b87866104079daade187"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#a67887375afa9b87866104079daade187">operator*</a> ()</td></tr>
<tr class="memdesc:a67887375afa9b87866104079daade187 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the public API for dereferencing the iterator to a (possibly) read-/write-able reference.  <br /></td></tr>
<tr class="separator:a67887375afa9b87866104079daade187 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70742253f032017ea1cb8712f34b572 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_ad70742253f032017ea1cb8712f34b572"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#ad70742253f032017ea1cb8712f34b572">operator*</a> () const</td></tr>
<tr class="memdesc:ad70742253f032017ea1cb8712f34b572 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the public API for dereferencing the iterator to a read-only reference.  <br /></td></tr>
<tr class="separator:ad70742253f032017ea1cb8712f34b572 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab467433b4c660360f19b5e3b437e7220 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_ab467433b4c660360f19b5e3b437e7220"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#ab467433b4c660360f19b5e3b437e7220">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:ab467433b4c660360f19b5e3b437e7220 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to an element's member functions directly.  <br /></td></tr>
<tr class="separator:ab467433b4c660360f19b5e3b437e7220 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4541c0210b05071b72e056f11649323c inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_a4541c0210b05071b72e056f11649323c"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#a4541c0210b05071b72e056f11649323c">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a4541c0210b05071b72e056f11649323c inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to an element's member functions directly.  <br /></td></tr>
<tr class="separator:a4541c0210b05071b72e056f11649323c inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bed4b4e12b6392aa581a724804fc0a inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_a14bed4b4e12b6392aa581a724804fc0a"><td class="memItemLeft" align="right" valign="top">ParentType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#a14bed4b4e12b6392aa581a724804fc0a">operator++</a> ()</td></tr>
<tr class="memdesc:a14bed4b4e12b6392aa581a724804fc0a inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the current iterator and returns it.  <br /></td></tr>
<tr class="separator:a14bed4b4e12b6392aa581a724804fc0a inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7130bfdbfbcb17d4545a12d7b4ae8718 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_a7130bfdbfbcb17d4545a12d7b4ae8718"><td class="memItemLeft" align="right" valign="top">ParentType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#a7130bfdbfbcb17d4545a12d7b4ae8718">operator++</a> (int)</td></tr>
<tr class="memdesc:a7130bfdbfbcb17d4545a12d7b4ae8718 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator before incrementing it.  <br /></td></tr>
<tr class="separator:a7130bfdbfbcb17d4545a12d7b4ae8718 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5d8ccf14b92b0bedefbfaeda4ab9b inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_a82f5d8ccf14b92b0bedefbfaeda4ab9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#a82f5d8ccf14b92b0bedefbfaeda4ab9b">operator==</a> (const <a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html">InputIteratorBase</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a82f5d8ccf14b92b0bedefbfaeda4ab9b inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two iterators point to the same element.  <br /></td></tr>
<tr class="separator:a82f5d8ccf14b92b0bedefbfaeda4ab9b inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200072f65d1a78b0bf4aeb269bed7684 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_a200072f65d1a78b0bf4aeb269bed7684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html#a200072f65d1a78b0bf4aeb269bed7684">operator!=</a> (const <a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html">InputIteratorBase</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a200072f65d1a78b0bf4aeb269bed7684 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two iterators point to different elements.  <br /></td></tr>
<tr class="separator:a200072f65d1a78b0bf4aeb269bed7684 inherit pub_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classutilities_1_1iterators_1_1InputIteratorBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html">utilities::iterators::InputIteratorBase&lt; ParentType &gt;</a></td></tr>
<tr class="memitem:ab2c136e108ab5a0cb81c1a47510f25c5 inherit pro_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_ab2c136e108ab5a0cb81c1a47510f25c5"><td class="memItemLeft" align="right" valign="top">
ParentType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>downcast_</b> () noexcept</td></tr>
<tr class="memdesc:ab2c136e108ab5a0cb81c1a47510f25c5 inherit pro_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcasts this to a read-/write-able instance of the derived class. <br /></td></tr>
<tr class="separator:ab2c136e108ab5a0cb81c1a47510f25c5 inherit pro_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30cd6620d4f3bd6c5b57e822fd7c428 inherit pro_methods_classutilities_1_1iterators_1_1InputIteratorBase" id="r_ab30cd6620d4f3bd6c5b57e822fd7c428"><td class="memItemLeft" align="right" valign="top">
const ParentType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>downcast_</b> () const noexcept</td></tr>
<tr class="memdesc:ab30cd6620d4f3bd6c5b57e822fd7c428 inherit pro_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcasts this instance to a read-only instance of the derived class. <br /></td></tr>
<tr class="separator:ab30cd6620d4f3bd6c5b57e822fd7c428 inherit pro_methods_classutilities_1_1iterators_1_1InputIteratorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ParentType&gt;<br />
struct utilities::iterators::RandomAccessIteratorBase&lt; ParentType &gt;</div><p>This class is designed to facilitate making your own random access iterator class. </p>
<p>To use this class your derived class needs to implement the functions for the <a class="el" href="classutilities_1_1iterators_1_1InputIteratorBase.html" title="This class is designed to facilitate making your own input iterator class.">InputIteratorBase</a> and <a class="el" href="structutilities_1_1iterators_1_1BidirectionalIteratorBase.html" title="This class is designed to facilitate making your own bidirectional iterator class.">BidirectionalIteratorBase</a> classes:</p><ul>
<li><code>ParentType&amp; increment()</code></li>
<li><code>const_reference dereference()const</code></li>
<li><code>reference dereference()</code></li>
<li><code>bool are_equal(const ParentType&amp;) const noexcept</code></li>
<li><code>ParentType&amp; decrement()</code></li>
</ul>
<p>As well as:</p>
<ul>
<li><code>ParentType&amp; advance(difference_type)</code> - If the argument is positive this function should increment the current iterator by the specified number of iterations and return the result. Otherwise, if the argument is negative this function should decrement the current iterator by the specified number of iterations and return the result. The implementation is free to throw if it chooses.</li>
<li><code>difference_type distance_to(const ParentType&amp;) const</code> - Determines the number of iterations required to make the current iterator point to the same element as the argument. A positive value indicates that the current iterator is behind the argument and a negative value indicates that the current iterator is ahead of the argument. The user's implementation may throw if, for example, the argument iterator is unreachable.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParentType</td><td>The type of the derived class, which is implementing this <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html" title="This class is designed to facilitate making your own random access iterator class.">RandomAccessIteratorBase</a> instance. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a942223007a00a9ecadae2bc818fb1885" name="a942223007a00a9ecadae2bc818fb1885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942223007a00a9ecadae2bc818fb1885">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
<div class="memtemplate">
template&lt;typename DifferenceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParentType <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">DifferenceType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of the current iterator that points to the element a specified number of iterations away. </p>
<p>This function is used to create a new iterator that has been incremented (if <code>n</code> is positive) or decremented (if <code>n</code> is negative) relative to the current iterator by the specified number of iterations. This function ultimately works by calling the derived class's copy constructor and <code>advance</code> member.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DifferenceType</td><td>The type of <code>n</code>. Assumed to be a signed integral POD type such as long int.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of iterations to move forward by. If <code>n</code> is negative then the iterator will actually move backward by <code>n</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current iterator pointing to the element <code>n</code> iterations away. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's copy constructor or <code>advance()</code> member throw. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba40fa49994cd5db57e6c6237030261a" name="aba40fa49994cd5db57e6c6237030261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba40fa49994cd5db57e6c6237030261a">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
<div class="memtemplate">
template&lt;typename DifferenceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParentType &amp; <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">DifferenceType &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the current iterator the specified number of iterations. </p>
<p>This function is used to increment (if <code>n</code> is positive) or decrement (if <code>n</code> is negative) the current iterator by the specified number of iterations. This function ultimately works by calling the derived class's <code>advance</code> member.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DifferenceType</td><td>The type of <code>n</code>. Assumed to be a signed integral POD type such as long int.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of iterations to advance by. If <code>n</code> is negative then the iterator will actually move backward by <code>n</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator incremented or decremented by <code>n</code> elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's <code>advance()</code> method throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af29b36038a32711d0aeb8e5487aca261" name="af29b36038a32711d0aeb8e5487aca261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29b36038a32711d0aeb8e5487aca261">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const ParentType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance between this iterator and another iterator. </p>
<p>This function will return the number of iterations required to make <code>rhs</code> equal this iterator. If the returned value is positive it means that <code>rhs</code> is behind this iterator, whereas a negative value means that <code>rhs</code> is ahead of this iterator (a value of zero means they point to the same element). This function ultimately works by calling the derived class's <code>distance_to</code> member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The iterator to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed integral POD type containing the distance between this iterator and <code>rhs</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If <code>distance_to</code> throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6031b56177492011b29ebe8e37752ad1" name="a6031b56177492011b29ebe8e37752ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6031b56177492011b29ebe8e37752ad1">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
<div class="memtemplate">
template&lt;typename DifferenceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParentType <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">DifferenceType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of the current iterator that points to the element a specified number of iterations away. </p>
<p>This function is used to create a new iterator that has been decremented (if <code>n</code> is positive) or incremented (if <code>n</code> is negative) relative to the current iterator by the specified number of iterations. This function ultimately works by calling the derived class's copy constructor and <code>advance</code> member with <code>n</code> multiplied by negative 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DifferenceType</td><td>The type of <code>n</code>. Assumed to be a signed integral POD type such as long int.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of iterations to move backward by. If <code>n</code> is negative then the iterator will actually move forward by <code>n</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current iterator pointing to the element <code>n</code> iterations away. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's copy constructor or <code>advance()</code> member throw. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c7b8026a2e379f3710f7c8c7323a065" name="a4c7b8026a2e379f3710f7c8c7323a065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7b8026a2e379f3710f7c8c7323a065">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
<div class="memtemplate">
template&lt;typename DifferenceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParentType &amp; <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">DifferenceType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retreats the current iterator the specified number of iterations. </p>
<p>This function is used to decrement (if <code>n</code> is positive) or increment (if <code>n</code> is negative) the current iterator by the specified number of iterations. This function ultimately works by calling the derived class's <code>advance</code> member with <code>n</code> multiplied by negative 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DifferenceType</td><td>The type of <code>n</code>. Assumed to be a signed integral POD type such as long int.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of iterations to retreat by. If <code>n</code> is negative then the iterator will actually advance by <code>n</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator incremented or decremented by <code>n</code> elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's <code>advance()</code> method throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a6fbc89f1128ab11a902b5cf7632b19" name="a1a6fbc89f1128ab11a902b5cf7632b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6fbc89f1128ab11a902b5cf7632b19">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const ParentType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two iterators and returns true if the current iterator points to an element appearing earlier in the container. </p>
<p>This function ultimately calls derived class's <code>distance_to</code> member and then uses the fact that a positive distance means that <code>rhs</code> points to an element further in the sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The iterator to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the current iterator points to an element indexed earlier than the element pointed to by <code>rhs</code> and false otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's <code>distance_to</code> member throws. Same throw guarante.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afff09b242f7e573c872a6ae1a80b07a5" name="afff09b242f7e573c872a6ae1a80b07a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff09b242f7e573c872a6ae1a80b07a5">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ParentType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two iterators and returns true if the current iterator points to an element appearing earlier in the container or if the two iterators point to the same element. </p>
<p>This function ultimately works by calling the derived class's <code>distance_to</code> member and using the fact that if <code>rhs</code> is not less than this instance, than this instance must be equal to or greater to <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The iterator to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the current iterator points to the same index as <code>rhs</code> or an early index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's <code>distance_to</code> member throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a702be4c438d46627aec5b85ca1764" name="ab5a702be4c438d46627aec5b85ca1764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a702be4c438d46627aec5b85ca1764">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const ParentType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two iterators and returns true if this iterator points to an element later in the container than the rhs iterator. </p>
<p>This function ultimately calls the derived class's <code>distance_to</code> member and uses the fact that if <code>rhs</code> is less than this instance, than this instance must be greater than <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The iterator to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the current element is indexed after that of <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's <code>distance_to</code> member throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5facaf63677a629947a64f2cf5307257" name="a5facaf63677a629947a64f2cf5307257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5facaf63677a629947a64f2cf5307257">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const ParentType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two iterators and returns true if they point to the same element, or if the element pointed to by this iterator occurs later in the sequence than that of the rhs iterator. </p>
<p>This function ultimately calls <code>distance_to</code> and relies on the fact that if this instance is not less than <code>rhs</code>, than it must be greater than or equal to <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The iterator to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the current iterator points to the same element or an element later in the sequence than the one pointed to by <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If <code>distance_to</code> throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682164d8a32b3af409f7b8bf567dfdff" name="a682164d8a32b3af409f7b8bf567dfdff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682164d8a32b3af409f7b8bf567dfdff">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParentType &gt; </div>
<div class="memtemplate">
template&lt;typename DifferenceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structutilities_1_1iterators_1_1RandomAccessIteratorBase.html">utilities::iterators::RandomAccessIteratorBase</a>&lt; ParentType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">DifferenceType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides random access to any element in the container relative to the element currently pointed to by this iterator. </p>
<p>This function will return the element that is <code>n</code> iterations away from the element current being pointed at. The current iterator will still point to the same element after this function has been called. This function ultimately works by calling the derived class's copy constructor and the <code>advance()</code> member.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DifferenceType</td><td>The type of <code>n</code>. Assumed to be a signed integral POD type such as long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The index, relative to the currently pointed to element, of the desired element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element that is <code>n</code> iterations away. The returned element will be of whatever type is returned by the non-const <code>dereference()</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the derived class's copy constructor of <code>advance</code> member throw strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/utilities/iterators/<a class="el" href="random__access__iterator__base_8hpp_source.html">random_access_iterator_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
